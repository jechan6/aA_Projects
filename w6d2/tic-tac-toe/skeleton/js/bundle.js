!function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=1)}([function(e,t){e.exports=function(e){this.msg=e}},function(e,t,r){const n=r(2),o=r(3);$(()=>{const e=new o,t=$(".ttt");new n(e,t),$("li")})},function(e,t){e.exports=class{constructor(e,t){this.game=e,this.el=t,this.setupBoard(),this.li=this.el.children().children(),this.bindEvents()}bindEvents(){this.li.hover(function(){$(this).addClass("hover")},function(){$(this).removeClass("hover")}),this.li.on("click",e=>{$(e.currentTarget).off("mouseenter mouseleave click"),$(e.currentTarget).addClass("clicked"),$(e.currentTarget).removeClass("hover"),this.makeMove($(e.currentTarget)),this.game.playMove($(e.currentTarget).data("pos")),this.checkWinner()})}checkWinner(){this.game.isOver()&&($(this.li).off("mouseenter mouseleave click"),this.game.winner()?(this.renderWinner(),$(".winner").text(`You win, ${this.game.winner()}!`)):(this.renderDraw(),$(".winner").text("ITS A DRAW")))}renderWinner(){this.li.each((e,t)=>{console.log(e),$(t).text()===this.game.winner()?$(t).css("background","green"):$(t).css("color","red")})}renderDraw(){this.li.each((e,t)=>{console.log(t),$(t).css("color","red")})}makeMove(e){e.text(this.game.currentPlayer)}setupBoard(){const e=$("<ul> </ul>");for(let t=0;t<3;t++)for(let r=0;r<3;r++){const n=$("<li></li>");n.data("pos",[t,r]),e.append(n)}this.el.append(e)}}},function(e,t,r){const n=r(4),o=r(0);e.exports=class{constructor(){this.board=new n,this.currentPlayer=n.marks[0]}isOver(){return this.board.isOver()}playMove(e){console.log(e),this.board.placeMark(e,this.currentPlayer),this.swapTurn()}promptMove(e,t){this.board.print(),console.log(`Current Turn: ${this.currentPlayer}`),e.question("Enter rowIdx: ",r=>{const n=parseInt(r);e.question("Enter colIdx: ",e=>{const r=parseInt(e);t([n,r])})})}run(e,t){this.promptMove(e,r=>{try{this.playMove(r)}catch(e){if(!(e instanceof o))throw e;console.log(e.msg)}this.isOver()?(this.board.print(),this.winner()?console.log(`${this.winner()} has won!`):console.log("NO ONE WINS!"),t()):this.run(e,t)})}swapTurn(){this.currentPlayer===n.marks[0]?this.currentPlayer=n.marks[1]:this.currentPlayer=n.marks[0]}winner(){return this.board.winner()}}},function(e,t,r){const n=r(0);class o{constructor(){this.grid=o.makeGrid()}isEmptyPos(e){if(!o.isValidPos(e))throw new n("Is not valid position!");return null===this.grid[e[0]][e[1]]}isOver(){if(null!=this.winner())return!0;for(let e=0;e<3;e++)for(let t=0;t<3;t++)if(this.isEmptyPos([e,t]))return!1;return!0}placeMark(e,t){if(!this.isEmptyPos(e))throw new n("Is not an empty position!");this.grid[e[0]][e[1]]=t}print(){const e=[];for(let t=0;t<3;t++){const r=[];for(let e=0;e<3;e++)r.push(this.grid[t][e]?this.grid[t][e]:" ");e.push(`${r.join("|")}\n`)}console.log(e.join("-----\n"))}winner(){const e=[[[0,0],[0,1],[0,2]],[[1,0],[1,1],[1,2]],[[2,0],[2,1],[2,2]],[[0,0],[1,0],[2,0]],[[0,1],[1,1],[2,1]],[[0,2],[1,2],[2,2]],[[0,0],[1,1],[2,2]],[[2,0],[1,1],[0,2]]];for(let t=0;t<e.length;t++){const r=this.winnerHelper(e[t]);if(null!=r)return r}return null}winnerHelper(e){for(let t=0;t<o.marks.length;t++){const r=o.marks[t];let n=!0;for(let t=0;t<3;t++){const o=e[t];this.grid[o[0]][o[1]]!=r&&(n=!1)}if(n)return r}return null}static isValidPos(e){return 0<=e[0]&&e[0]<3&&0<=e[1]&&e[1]<3}static makeGrid(){const e=[];for(let t=0;t<3;t++){e.push([]);for(let r=0;r<3;r++)e[t].push(null)}return e}}o.marks=["x","o"],e.exports=o}]);